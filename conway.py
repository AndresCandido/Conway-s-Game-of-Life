# -*- coding: utf-8 -*-
"""conway.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1071Jlbf7phnYNZD5sactdoyU_qDO2RYG
"""

## Conway’s Game of Life by Andres Candido

import sys
import os
import random
import math
import time

# Ask user for the board dimensions
while True:
    size = input("Please enter the board size (int): ")
    try:
        size = int(size)
        break
    except ValueError:
        print("Invalid input. Please try again.")

# Initialize the board and let user select initial state
ROWS = size;    # how tall the grid is
COLS = size*2;  # how wide the grid is 
GEN = 0;        # start generation counter


# Ask user for the initial board pattern
choice=0;
print("Choose an initial board state:\nRandom\t\t[1]\nTriangle\t[2]\nSquare\t\t[3]\nCircle\t\t[4]\nMystery\t\t[5]")
while (choice<1 or choice>5):
    choice = input("Please select an initial state from the list (int): ")
    try:
        choice = int(choice)

    except ValueError:
        print("Invalid input. Please try again.")
        choice=0;

    else:
        if (choice<1 or choice>5):
          print("Invalid input. Please try again.")
          
if (choice==1):
  board = [[random.choice(["X", " "]) for c in range(COLS)] for r in range(ROWS)] # board is a 2d array 

elif (choice==2):
  board = [[" " for c in range(COLS)] for r in range(ROWS)]
  # Draw a triangle in the middle of the board
  for r in range(ROWS):
      for c in range(COLS):
          if c >= COLS/2 - r and c <= COLS/2 + r:
              board[r][c] = "X"

elif (choice==3):
  # Define the size of the square
  square_size = min(ROWS, COLS) // 2

  # Initialize the board with a square in the middle
  board = [[" " for c in range(COLS)] for r in range(ROWS)]
  start_row = ROWS // 2 - square_size // 2
  start_col = COLS // 2 - square_size // 2
  for r in range(start_row, start_row + square_size):
      for c in range(start_col, start_col + square_size):
          board[r][c] = "X"

elif (choice==4):
  # Define the radius of the circle
  radius = min(ROWS, COLS) // 4

  # Initialize the board with a circle in the middle
  board = [[" " for c in range(COLS)] for r in range(ROWS)]
  for r in range(ROWS):
      for c in range(COLS):
          if math.sqrt((r - ROWS/2)**2 + (c - COLS/2)**2) <= radius:
              board[r][c] = "X"

elif (choice==5):
  # Initialize the board with a cross in the middle
  board = [["X" if r == ROWS // 2 or c == COLS // 2 else " " for c in range(COLS)] for r in range(ROWS)]

# ------------------------ Functions ----------------------------------
# clear the terminal window
def clear():
    if os.name == "posix":
        os.system("clear")
    else:
        os.system("cls")

# print the board with borders and encapsulation
def print_board(board):
    clear()
    print("*" + "-" * COLS + "*")
    for r in range(ROWS):
        print("|" + "".join(board[r]) + "|")
    print("*" + "-" * COLS + "*")

# count the number of live neighbors for a cell
def count_neighbors(board, r, c):
    count = 0
    for i in range(-1, 2):
        for j in range(-1, 2):
            row = (r + i + ROWS) % ROWS
            col = (c + j + COLS) % COLS
            if board[row][col] == "X":
                count += 1
    if board[r][c] == "X":
        count -= 1
    return count

# -------------------------- Main game loop ----------------------------------
while GEN <= 100:
    print_board(board)
    print(" "*(int((COLS-13)/2)), "Generation:", GEN)

    # Create a copy of the board to store the next generation
    next_board = [[board[r][c] for c in range(COLS)] for r in range(ROWS)]

    # Update each cell in the next generation
    for r in range(ROWS):
        for c in range(COLS):
            neighbors = count_neighbors(board, r, c)
            if board[r][c] == "X" and (neighbors < 2 or neighbors > 3): # if cell is alive and has 2 or 3 neighbors ⇒ alive, otherwise cell ⇒ dead
                next_board[r][c] = " "
            elif board[r][c] == " " and neighbors == 3: # if cell is dead and has 3 neighbors ⇒ alive
                next_board[r][c] = "X"

    # Update the board with the next generation
    board = next_board
    GEN += 1

    # Wait for a short period of time before updating the board again
    time.sleep(0.2)